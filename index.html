<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sua's Snack Catch!</title>
    <style>
        html, body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            background: #000; 
        }
        canvas { 
            display: block; 
            background: #90CAF9; 
            image-rendering: pixelated; 
        }
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        // 1. ê¸°ë³¸ ì„¤ì •
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // 2. ê²Œì„ ë³€ìˆ˜ ì„¤ì •
        let score = 0;
        let snackBaseSpeed = 3; 
        let gameOver = false;
        const gravity = 0.2; // ë°©í•´ë¬¼ ì¤‘ë ¥

        // ì‚¬ìš´ë“œ ê°ì²´
        const catchSound = new Audio('catch.mp3');
        const gameOverSound = new Audio('gameover.mp3');

        let snackSpawnInterval = 1000; 

        // 3. ì´ë¯¸ì§€ ë¡œë“œ (ì´ 7ê°œ - ë³€ê²½ ì—†ìŒ)
        const playerImage = new Image();
        playerImage.src = 'player_basket.png';
        const throwerImage = new Image();
        throwerImage.src = 'thrower_character.png';
        const backgroundImage = new Image();
        backgroundImage.src = 'background_house_sky.png';
        const obstacleImage = new Image(); 
        obstacleImage.src = 'obstacle.png';

        const peperoImage = new Image(); // ë¹¼ë¹¼ë¡œ
        peperoImage.src = 'pepero_stick.png';
        const snackBImage = new Image(); // ì¿ í‚¤
        snackBImage.src = 'snack_b.png';
        const snackCImage = new Image(); // ì´ˆì½œë¦¿ (ì‚¬íƒ• ëŒ€ì‹ )
        snackCImage.src = 'snack_c.png';


        let imagesLoaded = 0;
        const totalImages = 7; 

        function imageLoaded() {
            imagesLoaded++;
            if (imagesLoaded === totalImages) {
                console.log("All images loaded!");
                gameLoop();
                spawnSnack(); 
                setTimeout(spawnObstacle, 3000); 
            }
        }

        playerImage.onload = imageLoaded;
        throwerImage.onload = imageLoaded;
        backgroundImage.onload = imageLoaded; 
        obstacleImage.onload = imageLoaded; 
        peperoImage.onload = imageLoaded;
        snackBImage.onload = imageLoaded;
        snackCImage.onload = imageLoaded;

        // ë¡œë“œ ì˜¤ë¥˜ ì²˜ë¦¬ (ë™ì¼)
        playerImage.onerror = () => console.error("Failed to load player_basket.png");
        throwerImage.onerror = () => console.error("Failed to load thrower_character.png");
        backgroundImage.onerror = () => console.error("Failed to load background_house_sky.png");
        obstacleImage.onerror = () => console.error("Failed to load obstacle.png");
        peperoImage.onerror = () => console.error("Failed to load pepero_stick.png");
        snackBImage.onerror = () => console.error("Failed to load snack_b.png");
        snackCImage.onerror = () => console.error("Failed to load snack_c.png");


        // ë°”êµ¬ë‹ˆ (í”Œë ˆì´ì–´) ì„¤ì • (ë™ì¼)
        const basket = {
            x: canvas.width / 2 - 50, 
            y: canvas.height - 200, 
            width: 100, 
            height: 180, 
        };
        
        // ë˜ì§€ëŠ” ìºë¦­í„° ì„¤ì • (ë™ì¼)
        const thrower = {
            width: 100, 
            height: 140,
            x: canvas.width - 120, 
            y: canvas.height * 0.35, 
        };

        // ì•„ì´í…œ ë°°ì—´ (ê°„ì‹ + ë°©í•´ë¬¼) (ë™ì¼)
        let items = [];

        // 4. ëª¨ë°”ì¼ í„°ì¹˜ ì»¨íŠ¸ë¡¤ (ë™ì¼)
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); 
            if (gameOver) return;
            let touchX = e.touches[0].clientX;
            if (touchX > basket.width / 2 && touchX < canvas.width - basket.width / 2) {
                basket.x = touchX - basket.width / 2;
            }
        }, { passive: false }); 

        canvas.addEventListener('touchstart', () => { if (gameOver) resetGame(); });
        canvas.addEventListener('mousedown', () => { if (gameOver) resetGame(); });

        // 5. ğŸš¨ ìƒì„± í•¨ìˆ˜ ìˆ˜ì •
        
        // 5-1. ğŸš¨ ê°„ì‹ ìƒì„± í•¨ìˆ˜ (ì›€ì§ì„ ë¡œì§ ë³€ê²½)
        function spawnSnack() {
            if (gameOver) return;

            const rand = Math.random();
            let snack = {};
            const startX = Math.random() * (canvas.width - 70);

            if (rand < 0.33) { // 1/3 ë¹¼ë¹¼ë¡œ (ìˆ˜ì§)
                snack = {
                    type: 'snack',
                    image: peperoImage,
                    x: startX,
                    y: 0, 
                    width: 70, 
                    height: 100,
                    velocityY: snackBaseSpeed, // ğŸš¨ ì¶”ê°€: ê° ì•„ì´í…œë³„ y ì†ë„
                    velocityX: 0,
                    rotation: 0, // ğŸš¨ ì¶”ê°€: íšŒì „ê°’
                    rotationSpeed: 0 // ğŸš¨ ì¶”ê°€: íšŒì „ ì†ë„
                };
            } else if (rand < 0.66) { // 1/3 ì¿ í‚¤ (ëŒ€ê°ì„ , ëŠë¦° ì¢Œìš° íŠ•ê¹€)
                snack = {
                    type: 'snack',
                    image: snackBImage,
                    x: startX,
                    y: 0,
                    width: 60,
                    height: 60,
                    velocityY: snackBaseSpeed * (0.8 + Math.random() * 0.4), // ğŸš¨ ë³€í™”: ê¸°ë³¸ ì†ë„ì—ì„œ +-20%
                    velocityX: Math.random() > 0.5 ? 1.5 : -1.5, // ğŸš¨ ë³€í™”: ì¢Œìš° ì†ë„ ì¡°ê¸ˆ ëŠë¦¬ê²Œ
                    rotation: 0,
                    rotationSpeed: 0
                };
            } else { // 1/3 ì´ˆì½œë¦¿ (íšŒì „í•˜ë©° ë‚™í•˜)
                snack = {
                    type: 'snack',
                    image: snackCImage,
                    x: startX,
                    y: 0,
                    width: 50,
                    height: 50,
                    velocityY: snackBaseSpeed * (0.9 + Math.random() * 0.2), // ğŸš¨ ë³€í™”: ê¸°ë³¸ ì†ë„ì—ì„œ +-10%
                    velocityX: (Math.random() - 0.5) * 1, // ğŸš¨ ë³€í™”: Xì¶•ìœ¼ë¡œë„ ë¯¸ì„¸í•˜ê²Œ ì›€ì§ì„
                    rotation: Math.random() * Math.PI * 2, // ğŸš¨ ì¶”ê°€: ì´ˆê¸° íšŒì „ê°’ ëœë¤
                    rotationSpeed: (Math.random() > 0.5 ? 0.05 : -0.05) * (0.5 + Math.random()) // ğŸš¨ ì¶”ê°€: íšŒì „ ì†ë„ ëœë¤
                };
            }
            items.push(snack);

            // ë‹¤ìŒ ê°„ì‹ ìƒì„±ì„ ì˜ˆì•½ (ì ì  ë¹¨ë¼ì§)
            setTimeout(spawnSnack, snackSpawnInterval);
        }

        // 5-2. ë°©í•´ë¬¼ ìƒì„± í•¨ìˆ˜ (ë™ì¼)
        function spawnObstacle() {
            if (gameOver) return;

            const targetX = basket.x + basket.width / 2;
            const targetY = basket.y + basket.height / 2;
            const startX = thrower.x + thrower.width / 2;
            const startY = thrower.y + thrower.height / 2;

            const timeToTargetFrames = 120; // 2ì´ˆ
            const deltaX = targetX - startX;
            const deltaY = targetY - startY;

            const velocityX = deltaX / timeToTargetFrames;
            const velocityY = (deltaY / timeToTargetFrames) - 0.5 * gravity * timeToTargetFrames;

            const obstacleSize = 40;
            const obstacle = {
                type: 'obstacle',
                x: startX - obstacleSize / 2,
                y: startY - obstacleSize / 2,
                width: obstacleSize,
                height: obstacleSize,
                velocityX: velocityX,
                velocityY: velocityY,
                rotation: 0, // ë°©í•´ë¬¼ë„ íšŒì „ê°’ ì¶”ê°€
                rotationSpeed: (Math.random() > 0.5 ? 0.08 : -0.08) * (0.5 + Math.random()) // ë°©í•´ë¬¼ íšŒì „ ì†ë„
            };
            items.push(obstacle);

            const nextObstacleTime = 4000 + Math.random() * 2000;
            setTimeout(spawnObstacle, nextObstacleTime);
        }

        // 6. ê²Œì„ ì¬ì‹œì‘ í•¨ìˆ˜ (ë™ì¼)
        function resetGame() {
            score = 0;
            snackBaseSpeed = 3; 
            snackSpawnInterval = 1000; 
            items = []; 
            gameOver = false;
            gameLoop();
            spawnSnack(); 
            setTimeout(spawnObstacle, 3000);
        }

        function endGame() {
            gameOver = true;
            gameOverSound.play();
        }

        function clearGame() {
            gameOver = true;
            alert('ì¶•í•˜í•©ë‹ˆë‹¤! ê°„ì‹ ì°½ê³ ê°€ ì—´ë¦½ë‹ˆë‹¤!');
            window.location.href = 'sua_snack_storage.html'; 
        }

        // 7. ğŸš¨ ê²Œì„ ë£¨í”„ (ë¬¼ë¦¬ ì—…ë°ì´íŠ¸ ëŒ€í­ ìˆ˜ì •)
        function gameLoop() {
            if (gameOver) {
                // ê²Œì„ ì˜¤ë²„ í™”ë©´ (ë™ì¼)
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'red';
                ctx.font = '40px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 40);
                ctx.fillStyle = 'white';
                ctx.font = '20px "Press Start 2P"';
                ctx.fillText('Tap to retry!', canvas.width / 2, canvas.height / 2 + 20);
                return;
            }

            // 7.1. ë°°ê²½ ê·¸ë¦¬ê¸° (ë™ì¼)
            if (backgroundImage.complete && backgroundImage.naturalHeight !== 0) {
                ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
            } else {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }

            // 7.2. ìºë¦­í„° ê·¸ë¦¬ê¸° (ë™ì¼)
            if (playerImage.complete) {
                ctx.drawImage(playerImage, basket.x, basket.y, basket.width, basket.height);
            }
            if (throwerImage.complete) {
                ctx.drawImage(throwerImage, thrower.x, thrower.y, thrower.width, thrower.height);
            }
            
            // 7.3. ğŸš¨ ì•„ì´í…œ ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸° (ëŒ€í­ ìˆ˜ì •)
            for (let i = items.length - 1; i >= 0; i--) {
                let item = items[i];
                
                // 7.3.1. ì•„ì´í…œ ì´ë™
                if (item.type === 'snack') {
                    item.y += item.velocityY; // ğŸš¨ item.velocityY ì‚¬ìš©
                    item.x += item.velocityX; 
                    item.rotation += item.rotationSpeed; // ğŸš¨ íšŒì „ ì ìš©

                    // í™”ë©´ ì¢Œìš° ë²½ì— íŠ•ê¸°ê¸° (ê°„ì‹ë§Œ)
                    if (item.x <= 0 || item.x + item.width >= canvas.width) {
                        item.velocityX *= -1; 
                    }
                } else if (item.type === 'obstacle') {
                    item.x += item.velocityX;
                    item.y += item.velocityY;
                    item.velocityY += gravity;
                    item.rotation += item.rotationSpeed; // ğŸš¨ ë°©í•´ë¬¼ë„ íšŒì „ ì ìš©
                }

                // 7.3.2. ì•„ì´í…œ ê·¸ë¦¬ê¸° (íšŒì „ ì ìš©)
                if (item.image && item.image.complete || (item.type === 'obstacle' && obstacleImage.complete)) {
                    ctx.save(); // í˜„ì¬ ìº”ë²„ìŠ¤ ìƒíƒœ ì €ì¥
                    ctx.translate(item.x + item.width / 2, item.y + item.height / 2); // ì¤‘ì‹¬ì  ì´ë™
                    ctx.rotate(item.rotation); // íšŒì „
                    // ì´ë¯¸ì§€ ê·¸ë¦¬ê¸° (ì¤‘ì‹¬ì ì„ ê¸°ì¤€ìœ¼ë¡œ ê·¸ë¦¬ê¸° ìœ„í•´ x, y ìœ„ì¹˜ ë³´ì •)
                    const img = item.type === 'obstacle' ? obstacleImage : item.image;
                    ctx.drawImage(img, -item.width / 2, -item.height / 2, item.width, item.height);
                    ctx.restore(); // ì €ì¥ëœ ìº”ë²„ìŠ¤ ìƒíƒœ ë³µì› (íšŒì „ ì›ìƒë³µêµ¬)
                }
                
                // 7.3.3. ì¶©ëŒ ê°ì§€ (ë°”êµ¬ë‹ˆì™€) (ë™ì¼)
                if (
                    item.y + item.height > basket.y &&
                    item.y < basket.y + basket.height &&
                    item.x < basket.x + basket.width &&
                    item.x + item.width > basket.x
                ) {
                    if (item.type === 'snack') { 
                        score++;
                        snackBaseSpeed += 0.05; 
                        if (snackSpawnInterval > 300) {
                            snackSpawnInterval -= 15; 
                        }
                        items.splice(i, 1);
                        catchSound.play();
                    } else if (item.type === 'obstacle') {
                        items.splice(i, 1);
                        endGame(); 
                        break; 
                    }
                } 
                // 7.3.4. ë°”ë‹¥ì— ë–¨ì–´ì§„ ì•„ì´í…œ (ë™ì¼)
                else if (item.y > canvas.height) {
                    if (item.type === 'snack') { 
                        endGame();
                        break;
                    } else if (item.type === 'obstacle') {
                        items.splice(i, 1);
                    }
                }
            }
            
            // 7.4. ì ìˆ˜ ë° íƒ€ì´í‹€ í‘œì‹œ (ë™ì¼)
            ctx.fillStyle = 'white';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 4;
            ctx.font = '20px "Press Start 2P"'; 
            ctx.textAlign = 'left';
            ctx.strokeText(`SCORE: ${score}`, 20, 45);
            ctx.fillText(`SCORE: ${score}`, 20, 45);

            ctx.textAlign = 'right';
            ctx.strokeText("ìˆ˜ì•„ì˜ ê°„ì‹ì°½ê³ ë¥¼ í„¸ì–´ë¼!", canvas.width - 20, 45);
            ctx.fillText("ìˆ˜ì•„ì˜ ê°„ì‹ì°½ê³ ë¥¼ í„¸ì–´ë¼!", canvas.width - 20, 45);

            // 7.5. í´ë¦¬ì–´ ì—¬ë¶€ í™•ì¸ (ë™ì¼)
            const clearScore = 100;
            if (score >= clearScore) {
                clearGame();
                return;
            }

            // 7.6. ë‹¤ìŒ í”„ë ˆì„ ìš”ì²­
            requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html>